# Operating-Platforms

Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
  The client is a company that is developing a web-based game based on their game Draw it or Lose it. They need a game application that includes teams, players, and unique games. The application must be capable of running the game and fulfilling all of the software requirements.

What did you do particularly well in developing this documentation?
  I believe that I did a particularly good job at grasping the concepts behind the software development. Writing the code to create unique game instances was quite enjoyable. 
  
What about the process of working through a design document did you find helpful when developing the code?
  Working through a design document helped me to ensure that I didn't miss any steps. The design document kept track of all of the requirements and served as a roadmap to keep me on track. Once I had coded everything mentioned in the design document, I knew I was done.
  
If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
  I would revise some of the reccomendations I made near the beginning of this course. I have since learned a great deal more about operating platforms and software development in general. I would like to update my reccomendations in light of my new knowledge.

How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?
  While developing my design, I tried to envision how the user would think while utalizing the app. The way that users think and the way that developers think is often very different. Failing to recognize those differences can lead to apps that are unusable for the average person.

How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?  
  I approach designing software by first breaking down the necessary components into small chunks. Most of these small chunks will be turned into individual functions. Working in small pieces that each do one thing well helps keep code error free and easy to maintain. 
